# 포팅매뉴얼

# 버전

- BackEnd
    
    |name|version|
    | --- | --- |
    | Java | 11 |
    | Spring Boot | 2.7.11 |
    | Spring Cloud | 2021.0.6 |
    | MySQL | 8.0.32 |
    | [nnz-common](https://github.com/eello/nnz-common) | 0.4.5 |
    | Docker | 23.0.4 |
    | firebase sdk | 9.1.1 |
    | Kafka | 3.1.2 |
    | Redis | 7.0.11 |

- FrontEnd
    
    |name|version|
    | --- | --- |
    | Flutter_secure_storage | 8.0.0 |
    | Get | 4.6.5 |
    | dio | 5.0.3 |
    | firebase | 2.12.0 |
    | geolocator | 9.0.01 |
    | google_maps_ | 2.0.111 |
    | oauth1 | 2.0.0 |
    | flutter_dotenv | 6.1.1 |
    | image_picker | 0.8.7+4 |
    

# 포트
|name|port|
| --- | --- |
| discovery-service | 8761 |
| gateway-service | 8000 |
| user-service | 8081 |
| show-service | 8082 |
| nanum-service | 8083 |
| tag-service | 8084 |
| admin-service | 8001 |
| crawling-service | 8002 |
| jenkins | 9090 |
| Kafa | 29092 |

# Dockerfile

- BackEnd
    - discovery-service/gateway-service/user-service/show-service/nanum-service/tag-service/admin-service
        
        ```bash
        # openjdk11을 베이스로 이미지를 만든다.
        FROM openjdk:11-jdk-slim
        
        # JAR_FILE 변수에 jar 파일을 등록
        ARG JAR_FILE=/build/libs/{서비스-이름}-0.0.1-SNAPSHOT.jar
        
        # build 된 jar 파일을 container 내부에 복사
        # 젠킨스 도커 -> 스프링 도커
        COPY ${JAR_FILE} ./app.jar
        
        EXPOSE {각 서비스의 포트}
        
        ENTRYPOINT ["java", "-jar", "app.jar"]
        ```
        
    - crawling-service
        
        ```bash
        # openjdk11을 베이스로 이미지를 만든다.
        FROM openjdk:11-jdk-slim
        
        # Selenium 사용 위해 Chrome 및 Chrome WebDriver 설치
        RUN apt-get update && \
            apt-get install -y wget unzip xvfb libxi6 libgconf-2-4 default-jdk libgbm-dev && \
            wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
        
        # NOTE dpkg -i exits nonzero due to missing dependencies
        RUN dpkg -i google-chrome-stable_current_amd64.deb; apt-get install -y -f
        #RUN apt-get update && \
        #    apt-get -f install && \
        #    apt-get clean
        
        RUN wget https://chromedriver.storage.googleapis.com/112.0.5615.49/chromedriver_linux64.zip && \
            unzip chromedriver_linux64.zip && \
            mv chromedriver /usr/bin/chromedriver && \
            chmod +x /usr/bin/chromedriver
        
        # JAR_FILE 변수에 jar 파일을 등록
        ARG JAR_FILE=/build/libs/nnz-crawling-0.0.1-SNAPSHOT.jar
        
        # build 된 jar 파일을 container 내부에 복사
        # 젠킨스 도커 -> 스프링 도커
        COPY ${JAR_FILE} ./app.jar
        
        EXPOSE 8002
        
        # jasypt 암호화 키 제공하려면
        ENTRYPOINT ["sh", "-c", "java ${JAVA_OPTS} -jar /app.jar"]
        ```
        

# EC2 환경 설정

### 방화벽 설정

```bash
# 방화벽 상태 확인
sudo ufw status verbose

# 방화벽 활성화
sudo ufw enable

# 들어오는 통신은 최대한 폐쇄적으로, 나가는 통신은 개방적으로.
# 들어오는 통신 차단
sudo ufw default deny incoming

# 나가는 통신 허용
sudo ufw default allow outgoing

sudo ufw allow ssh
sudo ufw allow http
sudo ufw allow https
sudo ufw reload
```

### NGINX 설치

```bash
sudo apt update
sudo apt install nginx
sudo systemctl start nginx # 서비스 시작
sudo systemctl status nginx # 서비스 상태 확인
```

```bash
sudo cp /etc/nginx/sites-available/default /etc/nginx/sites-available/nnz.conf
```

nnz.conf

```bash
server {
        listen 80 default_server;
        listen [::]:80 default_server;

        root /var/www/html;

        # Add index.php to the list if you are using PHP
        index index.html index.htm index.nginx-debian.html;

        server_name k8b207.p.ssafy.io;

        location / {
                # First attempt to serve request as file, then
                # as directory, then fall back to displaying a 404.
                try_files $uri $uri/ =404;
        }
}
```

### SSL 인증서 적용

```bash
# 인증서 설치를 위한 Certbot 설치
sudo apt update
sudo apt-get install letsencrypt -y
sudo apt install certbot python3-certbot-nginx
```

```bash
sudo certbot --nginx -d k8b207.p.ssafy.io
```

이메일 입력, 약관 동의, 이메일 공유할지 동의, http를 https로 리다이렉트할지를 체크한다.

적용 후 nnz.conf

```bash
server {
  
        root /var/www/html;

        # Add index.php to the list if you are using PHP
        index index.html index.htm index.nginx-debian.html;

        server_name k8b207.p.ssafy.io;

        location / {
                # First attempt to serve request as file, then
                # as directory, then fall back to displaying a 404.
                try_files $uri $uri/ =404;
        }

    listen [::]:443 ssl ipv6only=on; # managed by Certbot
    listen 443 ssl; # managed by Certbot
    ssl_certificate /etc/letsencrypt/live/k8b207.p.ssafy.io/fullchain.pem; # managed 
by Certbot
    ssl_certificate_key /etc/letsencrypt/live/k8b207.p.ssafy.io/privkey.pem; # managed by Certbot
    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot

}
server {
    if ($host = k8b207.p.ssafy.io) {
        return 301 https://$host$request_uri;
    } # managed by Certbot

        listen 80 default_server;
        listen [::]:80 default_server;

        server_name k8b207.p.ssafy.io;
    return 404; # managed by Certbot

}
```

### 도커 설치

1. 패키지 설치를 위해 apt-get 업데이트

  ```bash
  sudo apt-get update
  ```

2. 저장소를 https로 사용할 수 있도록 필요한 패키지 설치

  ```bash
  sudo apt-get install -y ca-certificates \
      curl \
      software-properties-common \
      apt-transport-https \
      gnupg \
      lsb-release
  ```

  ca-certificates : SSL 기반 웹 애플리케이션이  SSL 연결의 진위 여부를 판별할 수 있게 해준다.

  curl : URL로 서버에 데이터를 보내거나 가져올 수 있다.

  software-properties-common : 우분투에서 PPA를 사용하기 위한 패키지

  apt-transport-https : 패키지 관리자가 https를 통해 데이터나 패키지에 접근할 수 있게 한다.

  gnupg : 통신상에서 혹은 데이터를 저장할 때 보안을 지키는 도구

  lsb-release : 우분투 버전 확인

3. 도커의 GPG키를 등록

등록하는 명령어로 아래 2가지가 나오는데 apt-key는 deprecated 됐나보다.

[https://itsfoss.com/apt-key-deprecated/](https://itsfoss.com/apt-key-deprecated/)

  ```bash
  sudo mkdir -m 0755 -p /etc/apt/keyrings
  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
  ```

  ```bash
  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
  ```

4. repository 설정

  ```bash
  echo \
    "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
    $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
  ```

5. 도커 설치

  ```bash
  sudo apt-get update
  sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin
  ```

  ```bash
  sudo service docker start
  or
  sudo systemctl enable docker
  ```

6. 설치 확인

  ```bash
  # 도커 버전 확인
  ubuntu@ip-172-26-9-52:~$ sudo docker -v
  Docker version 23.0.4, build f480fb1

  ubuntu@ip-172-26-9-52:~$ sudo docker ps
  CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
  ```

### 서버 시간 설정

```bash
# 현재 시간 확인. 기본 설정인 UTC로 되어있다.
ubuntu@ip-172-26-9-52:~$ date
Tue Apr 25 03:52:30 UTC 2023
# 변경할 수 있는 timezone 리스트에 서울이 있는 확인
ubuntu@ip-172-26-9-52:~$ sudo timedatectl list-timezones | grep Seoul
Asia/Seoul
# 서버 타임을 변경한다.
ubuntu@ip-172-26-9-52:~$ sudo timedatectl set-timezone Asia/Seoul
# KST로 바뀌었다.
ubuntu@ip-172-26-9-52:~$ date
Tue Apr 25 12:53:03 KST 2023
```

### 젠킨스 설치

도커를 이용해서 젠킨스를 설치한다.

1. jenkins home 폴더 생성
    
    ```bash
    cd ~
    mkdir jenkins
    mkdir home
    ```
    
    ```bash
    ubuntu@ip-172-26-9-52:~$ pwd
    /home/ubuntu
    ubuntu@ip-172-26-9-52:~$ ls
    ubuntu@ip-172-26-9-52:~$ mkdir jenkins
    ubuntu@ip-172-26-9-52:~$ ls
    jenkins
    ubuntu@ip-172-26-9-52:~$ mkdir home
    ubuntu@ip-172-26-9-52:~$ ls
    home  jenkins
    ```
    

2. Docker Compose 작성
    
    ```bash
    cd ~/jenkins
    vim docker-compose.yaml
    ```
    
    ```bash
    version: '3.3'
    services:
    	jenkins:
    		image: jenkins/jenkins:lts-jdk11
    		container_name: jenkins
    		environment:
    			- TZ=Asia/Seoul
    		user: root
    		privileged: true
    		ports:
    			- 9090:8080
    			- 50000:50000
    		volumes:
    			- ./home:/var/jenkins_home
    			- /var/run/docker.sock:/var/run/docker.sock
    			- /usr/bin/docker:/usr/bin/docker
    ```
    
    image : 사용할 이미지
    
    container_name : 컨테이너 이름
    
    envionment : 컨테이너의 환경변수 설정
    
    user : 실행할 사용자 이름
    
    privileged : true로 설정하면 컨테이너 시스템의 주요 자원에 접근할 수 있다.
    
    ports : 호스트와 컨테이너의 포트를 연결해준다. 
    
    {로컬 port}:{컨테이너 port}. port forwarding
    
    8080은 Jenkins 기본 port이고 50000은 Jenkins slave port이다.
    
    volumes : 호스트와 컨테이너의 디렉토리를 연결해준다. mount
    
    /var/run/docker.sock:/var/run/docker.sock : docker in docker를 구현하기 위해 사용하는 옵션
    
3. Docker Compose 실행
    
    ```bash
    sudo docker-compose up -d
    ```
    
    ```bash
    ubuntu@ip-172-26-9-52:~/jenkins$ sudo docker ps
    CONTAINER ID   IMAGE                       COMMAND                  CREATED         STATUS         PORTS                                                                NAMES
    1a302c2cd14c   jenkins/jenkins:lts-jdk11   "/usr/bin/tini -- /u…"   2 minutes ago   Up 2 minutes   0.0.0.0:50000->50000/tcp, :::50000->50000/tcp,p, :::9090->8080/tcp   jenkins
    ```
    

### 젠킨스 기본 설정

1. 젠킨스 접속하기
    
    위의 패스워드에
    
    ```bash
    sudo docker logs jenkins
    ```
    
    해서 나온 패스워드를 입력한다.
    
    그리고 젠킨스 사용자 계정 생성한다.
    
    Install suggested plugin 설치
    

2. 플러그인 설치
    
    플러그인 GitLab, BlueOcean, SSH Agent 설치
    

3. credentials 만들기
    - gitlab setting에서 api token을 만든다.
    - jenkins에서 New Credentials
        
        a. GitLab API token으로 생성
        
        b. username with password으로 생성
        
        c. Secret text에 jenkins에서 도커 이미지를 올릴 도커 허브 패스워드 등록 ( id : dockerHubPwd)
        

### MySQL 설치

```bash
sudo apt-get update
sudo apt-get install mysql-server
mysql --version
```

```bash
sudo mysql_secure_installation
```

```bash
mysql> create database nnz_dev_db;
Query OK, 1 row affected (0.01 sec)

mysql> create user 'nnzyu'@'%' identified by '{password}';
Query OK, 0 rows affected (0.02 sec)

mysql> grant all privileges on *.* to 'nnzyu'@'%' with grant option;
Query OK, 0 rows affected (0.02 sec)

mysql> grant all privileges on nnzyu.* to 'nnzyu'@'%' with grant option;
Query OK, 0 rows affected (0.01 sec)

mysql> flush privileges;
Query OK, 0 rows affected (0.00 sec)
```

외부 접속 허용을 위해 

```bash
$ sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf
```

```bash
# 아래처럼 수정
bind-address = 0.0.0.0
```

```bash
ubuntu@ip-172-26-9-52:~$ sudo systemctl restart mysql.service
ubuntu@ip-172-26-9-52:~$ sudo systemctl status mysql.service
```

### Redis 설치

6379 포트를 열고 EC2에 Redis를 설치하면 해킹당한다.

일단 6379 포트를 닫고 EC2 안에서 내부적으로 연결할 방법을 찾았다.

1. 도커 컨테이너에 EC2 호스트를 연결하기
    
    docker run할때  --add-host 옵션으로 컨테이너가 연결할 호스트를 추가할 수 있다.
    
     --add-host [호스트명]:[IP 주소] : 컨테이너의 /etc/hosts/에 호스트명과 IP 주소를 정의
    
    DNS 이름 `host.docker.internal` 로 컨테이너 내부에서 host에 접근이 가능하다고 한다.
    
    docker run 옵션을 `-add-host=host.docker.internal:host-gateway`  이렇게 주고, application.yml에서 host : host.docker.internal, port : 6379 로 하니까 잘된다.
    

  ⇒ 그러나 Redis 연결이 가끔씩 끊기는 현상 발생

2. Redis를 docker로 올리고 서비스 컨테이너와 같은 도커 네트워크로 연결
    
    ```bash
    sudo docker pull redis
    sudo docker run -d --name redis  -p 6379:6379 --network nnz-network redis
    ```
    

  ⇒ 어차피 포트가 막혀있으니 비밀번호 설정을 하지 않아도 될거라 생각했지만 한 번 열었어서 그런가 계속 해킹당했다.

3. 비밀번호 설정 추가
    
    ```bash
    sudo docker run -d --name redis  -p 6379:6379 --network nnz-network redis redis-server --requirepass "{비밀번호}"
    ```
    
    ```bash
    sudo docker exec -it redis /bin/bash
    ```
    
    ```bash
    redis-cli
    auth {비밀번호}
    # 하면 권한을 얻을 수 있다.
    ```
    
### Kafka 설치

EC2 내부에 직접 설치하지 않고 docker-compose를 사용해 Zookeeper 서버와 Kafka를 같이 실행시킨다.

1. Kafka 폴더 생성
    ```bash
    mkdir ~/kafka
    ```

2. docker-compose.yml 작성
    ```bash
    vim ~/kafka/docker-compose.yml

    ### docker-compose.yml 파일 내부 ###
    version: '2'

    services:
      zookeeper:
        image: confluentinc/cp-zookeeper:latest
        environment:
          ZOOKEEPER_SERVER_ID: 1
          ZOOKEEPER_CLIENT_PORT: 2181
          ZOOKEEPER_TICK_TIME: 2000
          ZOOKEEPER_INIT_LIMIT: 5
          ZOOKEEPER_SYNC_LIMIT: 2
        ports:
          - "22181:2181"

      kafka:
        image: confluentinc/cp-kafka:latest
        depends_on:
          - zookeeper
        ports:
          - "29092:29092"
        environment:
          KAFKA_BROKER_ID: 1
          KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'
          KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092,PLAINTEXT_HOST://k8b207.p.ssafy.io:29092
          KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT
          KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT
          KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
          KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0
          KAFKA_DELETE_TOPIC_ENABLE: 'true'
          # KAFKA_AUTO_CREATE_TOPICS_ENABLE: 'true' # 없는 토픽 자동 생성 옵션
    ```

3. docker-compose 실행
    ```bash
    sudo docker-compose up -d
    ```

4. Zookeeper 서버, Kafka 실행 완료  
  ⇒ Kafka 기본 명령어 (위에 적힌 설정을 기준으로 작성)

    ```bash
    # 카프카 도커 컨테이너 접속
    cd ~/kafka
    sudo docker-compose exec kafka bash

    # 토픽 생성 (KAFKA_AUTO_CREATE_TOPICS_ENABLE의 기본값은 true로 어플리케이션에서 토픽을 생성하지 않고 전송하면 자동으로 해당 토픽이 생성된다.)
    kafka-topics --create --topic {topic-name} --bootstrap-server kafka:9092 --replication-factor 1 --partitions 1

    # 특정 토픽 확인
    kafka-topics --describe --topic {topic-name} --bootstrap-server kafka:9092

    # 생성된 토픽 리스트 확인
    kafka-topics --list --bootstrap-server kafka:9092

    # 컨슈머 실행
    kafka-console-consumer --topic {topic-name} --bootstrap-server kafka:9092

    # 프로듀서 실행
    kafka-console-producer --topic {topic-name} --broker-list kafka:9092
    ```

# 젠킨스 파이프라인 구성

### BackEnd

Jenkins script와 서비스 브랜치별 웹훅을 편하게 관리하기 위해 멀티브랜치 파이프라인을 사용했다.

1. 멀티브랜치 파이프라인 생성
    
    플러그인 설치 : Multibranch Scan Webhook Trigger, Pipeline: Multibranch, Pipeline: Multibranch with defaults
    
2. Branch Sources - Git 선택
    
    **Project Repository : 깃랩 주소 입력**
    
    Credentials : 깃랩 계정 연결
    
    Behaviours :  Filter by name 속성으로 원하는 브랜치 설정
    
3. Build Configuration
    
    멀티브랜치 파이프라인은 젠킨스 파이프라인 내에서 script 관리가 불가능하다. 
    
    깃랩 레포에 Jenkinfile을 두거나 젠킨스에 config file로 설정할 수 있다.
    
    우리는 Jenkins script 내에 설정 파일 암호화 키값을 저장할거라 깃랩에 둘 수 없어서 config 파일 방식을 선택했다.
    
    Jenkins 관리 메뉴 - Managed files - Add a new Config - groovy file 선택 후 id 설정해서 script 생성
    
    단 이렇게 하면 script 업데이트 후 최초 빌드시 스크립트가 승인되지 않았다면서 빌드 실패한다.
    
    Jenkins 관리 메뉴 - In-process Script Approval에서 승인을 해준 후 다시 빌드해야한다.
    
    매우 불편하지만 개선 방법을 찾지 못했다.
    
4. Scan Multibranch Pipeline Triggers
    
    깃랩에서 웹훅을 만든다.
    
    URL : **http://k8b207.p.ssafy.io:9090/project/{파이프라인 이름}**
    
    Secret token : 파이프라인과 매핑될 수 있는 토큰을 임의로 만든다.
    
    Trigger - Push events : 특정 한 브랜치를 타겟으로 하는게 아니기 때문에 빈 칸으로 둔다.
    
    Scan by webhook 선택
    
    깃랩 웹훅에 입력했던 token을 입력한다.
    
5. 파이프라인 생성 완료

- 사용한 script
    
    ```bash
    pipeline{
        agent any
        stages{
    		stage('Git Clone') {
    			steps {
    				echo "The build branch is ${env.BRANCH_NAME}"
    				git branch:"${env.BRANCH_NAME}",credentialsId: 'gitlab-username', url: 'https://lab.ssafy.com/s08-final/S08P31B207.git'
    			}
    		}
    		stage('Build Gradle') {
    			parallel {
    				stage('jenkins_test') {
    					when{branch 'dev_jenkins_test'}
    					steps {
    						dir("./be/JenkinsTest") {
    							sh 'pwd'
    							sh "chmod +x gradlew"
    							sh "./gradlew clean build -x test"
    							sh 'ls -al ./build'
    						}
    					}
    				}
    				stage('discovery') {
    					when{branch 'dev_discovery_service'}
    					steps {
    						dir("./be/discovery-service") {
    							sh 'pwd'
    							sh "chmod +x gradlew"
    							sh "./gradlew clean build -x test"
    							sh 'ls -al ./build'
    						}
    					}
    				}
    				stage('gateway') {
    					when{branch 'dev_gateway_service'}
    					steps {
    						dir("./be/gateway-service") {
    							sh 'pwd'
    							sh "chmod +x gradlew"
    							sh "./gradlew clean build -x test"
    							sh 'ls -al ./build'
    						}
    					}
    				}
    				stage('config') {
    					when{branch 'dev_config_service'}
    					steps {
    						dir("./be/config-service") {
    							sh 'pwd'
    							sh "chmod +x gradlew"
    							sh "./gradlew clean build -x test"
    							sh 'ls -al ./build'
    						}
    					}
    				}
    				stage('user') {
    					when{branch 'dev_user_service'}
    					steps {
    						dir("./be/user-service") {
    							sh 'pwd'
    							sh "chmod +x gradlew"
    							sh "./gradlew clean build -x test"
    							sh 'ls -al ./build'
    						}
    					}
    				}
    				stage('show') {
    					when{branch 'dev_show_service'}
    					steps {
    						dir("./be/show-service") {
    							sh 'pwd'
    							sh "chmod +x gradlew"
    							sh "./gradlew clean build -x test"
    							sh 'ls -al ./build'
    						}
    					}
    				}
    				stage('nanum') {
    					when{branch 'dev_nanum_service'}
    					steps {
    						dir("./be/nanum-service") {
    							sh 'pwd'
    							sh "chmod +x gradlew"
    							sh "./gradlew clean build -x test"
    							sh 'ls -al ./build'
    						}
    					}
    				}
    				stage('tag') {
    					when{branch 'dev_tag_service'}
    					steps {
    						dir("./be/tag-service") {
    							sh 'pwd'
    							sh "chmod +x gradlew"
    							sh "./gradlew clean build -x test"
    							sh 'ls -al ./build'
    						}
    					}
    				}
    				stage('admin') {
    					when{branch 'dev_admin_service'}
    					steps {
    						dir("./be/admin-service") {
    							sh 'pwd'
    							sh "chmod +x gradlew"
    							sh "./gradlew clean build -x test"
    							sh 'ls -al ./build'
    						}
    					}
    				}
    				stage('crawling') {
    					when{branch 'dev_crawling_service'}
    					steps {
    						dir("./be/nnz-crawling") {
    							sh 'pwd'
    							sh "chmod +x gradlew"
    							sh "./gradlew clean build -x test"
    							sh 'ls -al ./build'
    						}
    					}
    				}
    				/*
    				stage('user') {
    					when{branch 'dev_user_service'} # 브랜치 이름 바꾸기
    					steps {
    						dir("./be/user-service") { # 폴더 이름 바꾸기
    							sh 'pwd'
    							sh "chmod +x gradlew"
    							sh "./gradlew clean build -x test"
    							sh 'ls -al ./build'
    						}
    					}
    				}
    */
    			}
    		} 		
    		stage('Dockerizing'){
    			parallel {
    				stage('jenkins_test') {
    					when {branch 'dev_jenkins_test'}
    
    					stages{ 
    						stage('Docker build image'){
    								steps{
    									dir("./be/JenkinsTest") {
    										sh '''docker build . -t yuriyeom/dev-jenkins-test:latest'''
    									} 
    								}
    							}		
    						
    						stage('Docker push image'){
    								steps {
    									withCredentials([string(credentialsId: 'dockerHubPwd', variable: 'dockerHubPwd')]) {
    										sh '''docker login -u yuriyeom -p ${dockerHubPwd}'''
    									}
    									sh '''docker push yuriyeom/dev_jenkins_test '''
    								}
    						}
    						stage('Run Container on SSH Dev Server'){
    								steps{
    									sshagent (credentials: ['ssh-agent']) {
    									sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker rm -f dev_jenkins_test'"
    									sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker rmi -f yuriyeom/dev_jenkins_test'"
    									sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker pull yuriyeom/dev_jenkins_test:latest'"
    									sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker run -d --name dev_jenkins_test -p 8080:8080 --add-host=k8b207.p.ssafy.io:172.26.9.52 -e SPRING_PROFILES_ACTIVE=dev -e JAVA_OPTS=-Djasypt.encryptor.password={암호화 키} yuriyeom/dev_jenkins_test'"
    									}
    								}
    						}
    
    					}
    				}
    				stage('discovery') {
    					when {branch 'dev_discovery_service'}
    
    					stages{ 
    						stage('Docker build image'){
    								steps{
    									dir("./be/discovery-service") {
    										sh '''docker build . -t yuriyeom/dev-discovery-service:latest'''
    									} 
    								}
    							}		
    						
    						stage('Docker push image'){
    								steps {
    									withCredentials([string(credentialsId: 'dockerHubPwd', variable: 'dockerHubPwd')]) {
    										sh '''docker login -u yuriyeom -p ${dockerHubPwd}'''
    									}
    									sh '''docker push yuriyeom/dev-discovery-service '''
    								}
    						}
    						stage('Run Container on SSH Dev Server'){
    								steps{
    									sshagent (credentials: ['ssh-agent']) {
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker rm -f dev-discovery-service'"
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker rmi -f yuriyeom/dev-discovery-service'" 
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker pull yuriyeom/dev-discovery-service:latest'"
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker run -d --name dev-discovery-service -p 8761:8761 --network nnz-network yuriyeom/dev-discovery-service'"
    									}
    								}
    						}
    
    					}
    				}
    				stage('gateway') {
    					when {branch 'dev_gateway_service'}
    
    					stages{ 
    						stage('Docker build image'){
    								steps{
    									dir("./be/gateway-service") {
    										sh '''docker build . -t yuriyeom/dev-gateway-service:latest'''
    									} 
    								}
    							}		
    						
    						stage('Docker push image'){
    								steps {
    									withCredentials([string(credentialsId: 'dockerHubPwd', variable: 'dockerHubPwd')]) {
    										sh '''docker login -u yuriyeom -p ${dockerHubPwd}'''
    									}
    									sh '''docker push yuriyeom/dev-gateway-service '''
    								}
    						}
    						stage('Run Container on SSH Dev Server'){
    								steps{
    									sshagent (credentials: ['ssh-agent']) {
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker rm -f dev-gateway-service'"
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker rmi -f yuriyeom/dev-gateway-service'" 
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker pull yuriyeom/dev-gateway-service:latest'"
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker run -d --name dev-gateway-service -p 8000:8000 --network nnz-network -e SPRING_PROFILES_ACTIVE=dev -e JAVA_OPTS=-Djasypt.encryptor.password={암호화 키} yuriyeom/dev-gateway-service'"
    									}
    								}
    						}
    
    					}
    				}
    				stage('config') {
    					when {branch 'dev_config_service'}
    
    					stages{ 
    						stage('Docker build image'){
    								steps{
    									dir("./be/config-service") {
    										sh '''docker build . -t yuriyeom/dev-config-service:latest'''
    									} 
    								}
    							}		
    						
    						stage('Docker push image'){
    								steps {
    									withCredentials([string(credentialsId: 'dockerHubPwd', variable: 'dockerHubPwd')]) {
    										sh '''docker login -u yuriyeom -p ${dockerHubPwd}'''
    									}
    									sh '''docker push yuriyeom/dev-config-service '''
    								}
    						}
    						stage('Run Container on SSH Dev Server'){
    								steps{
    									sshagent (credentials: ['ssh-agent']) {
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker rm -f dev-config-service'"
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker rmi -f yuriyeom/dev-config-service'" 
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker pull yuriyeom/dev-config-service:latest'"
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker run -d --name dev-config-service -p 8888:8888 --network nnz-network -e SPRING_PROFILES_ACTIVE=dev -e JAVA_OPTS=-Djasypt.encryptor.password={암호화 키} yuriyeom/dev-config-service'"
    									}
    								}
    						}
    
    					}
    				}
    				stage('user') {
    					when {branch 'dev_user_service'}
    
    					stages{ 
    						stage('Docker build image'){
    								steps{
    									dir("./be/user-service") {
    										sh '''docker build . -t yuriyeom/dev-user-service:latest'''
    									} 
    								}
    							}		
    						
    						stage('Docker push image'){
    								steps {
    									withCredentials([string(credentialsId: 'dockerHubPwd', variable: 'dockerHubPwd')]) {
    										sh '''docker login -u yuriyeom -p ${dockerHubPwd}'''
    									}
    									sh '''docker push yuriyeom/dev-user-service '''
    								}
    						}
    						stage('Run Container on SSH Dev Server'){
    								steps{
    									sshagent (credentials: ['ssh-agent']) {
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker rm -f dev-user-service'"
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker rmi -f yuriyeom/dev-user-service'"
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker pull yuriyeom/dev-user-service:latest'"
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker run -d --name dev-user-service -p 8081:8081 --network nnz-network --add-host=host.docker.internal:host-gateway -e SPRING_PROFILES_ACTIVE=dev -e JAVA_OPTS=-Djasypt.encryptor.password={암호화 키} yuriyeom/dev-user-service'"
    									}
    								}
    						}
    
    					}
    				}
    				stage('show') {
    					when {branch 'dev_show_service'}
    
    					stages{ 
    						stage('Docker build image'){
    								steps{
    									dir("./be/show-service") {
    										sh '''docker build . -t yuriyeom/dev-show-service:latest'''
    									} 
    								}
    							}		
    						
    						stage('Docker push image'){
    								steps {
    									withCredentials([string(credentialsId: 'dockerHubPwd', variable: 'dockerHubPwd')]) {
    										sh '''docker login -u yuriyeom -p ${dockerHubPwd}'''
    									}
    									sh '''docker push yuriyeom/dev-show-service '''
    								}
    						}
    						stage('Run Container on SSH Dev Server'){
    								steps{
    									sshagent (credentials: ['ssh-agent']) {
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker rm -f dev-show-service'"
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker rmi -f yuriyeom/dev-show-service'" 
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker pull yuriyeom/dev-show-service:latest'"
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker run -d --name dev-show-service -p 8082:8082 --network nnz-network --add-host=host.docker.internal:host-gateway -e SPRING_PROFILES_ACTIVE=dev -e JAVA_OPTS=-Djasypt.encryptor.password={암호화 키} yuriyeom/dev-show-service'"
    									}
    								}
    						}
    
    					}
    				}
    				stage('nanum') {
    					when {branch 'dev_nanum_service'}
    
    					stages{ 
    						stage('Docker build image'){
    								steps{
    									dir("./be/nanum-service") {
    										sh '''docker build . -t yuriyeom/dev-nanum-service:latest'''
    									} 
    								}
    							}		
    						
    						stage('Docker push image'){
    								steps {
    									withCredentials([string(credentialsId: 'dockerHubPwd', variable: 'dockerHubPwd')]) {
    										sh '''docker login -u yuriyeom -p ${dockerHubPwd}'''
    									}
    									sh '''docker push yuriyeom/dev-nanum-service '''
    								}
    						}
    						stage('Run Container on SSH Dev Server'){
    								steps{
    									sshagent (credentials: ['ssh-agent']) {
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker rm -f dev-nanum-service'"
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker rmi -f yuriyeom/dev-nanum-service'" 
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker pull yuriyeom/dev-nanum-service:latest'"
                                            sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io ' sudo docker run -d --name dev-nanum-service -p 8083:8083 --network nnz-network --add-host=host.docker.internal:host-gateway -e SPRING_PROFILES_ACTIVE=dev -e JAVA_OPTS=-Djasypt.encryptor.password={암호화 키} -v `pwd`:/home yuriyeom/dev-nanum-service'"
    									}
    								}
    						}
    
    					}
    				}
    				
    				stage('tag') {
    					when {branch 'dev_tag_service'}
    
    					stages{ 
    						stage('Docker build image'){
    								steps{
    									dir("./be/tag-service") {
    										sh '''docker build . -t yuriyeom/dev-tag-service:latest'''
    									} 
    								}
    							}		
    						
    						stage('Docker push image'){
    								steps {
    									withCredentials([string(credentialsId: 'dockerHubPwd', variable: 'dockerHubPwd')]) {
    										sh '''docker login -u yuriyeom -p ${dockerHubPwd}'''
    									}
    									sh '''docker push yuriyeom/dev-tag-service '''
    								}
    						}
    						stage('Run Container on SSH Dev Server'){
    								steps{
    									sshagent (credentials: ['ssh-agent']) {
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker rm -f dev-tag-service'"
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker rmi -f yuriyeom/dev-tag-service'" 
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker pull yuriyeom/dev-tag-service:latest'"
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker run -d --name dev-tag-service -p 8084:8084 --network nnz-network --add-host=host.docker.internal:host-gateway -e SPRING_PROFILES_ACTIVE=dev -e JAVA_OPTS=-Djasypt.encryptor.password={암호화 키} yuriyeom/dev-tag-service'"
    									}
    								}
    						}
    
    					}
    				}
    				stage('admin') {
    					when {branch 'dev_admin_service'}
    
    					stages{ 
    						stage('Docker build image'){
    								steps{
    									dir("./be/admin-service") {
    										sh '''docker build . -t yuriyeom/dev-admin-service:latest'''
    									} 
    								}
    							}		
    						
    						stage('Docker push image'){
    								steps {
    									withCredentials([string(credentialsId: 'dockerHubPwd', variable: 'dockerHubPwd')]) {
    										sh '''docker login -u yuriyeom -p ${dockerHubPwd}'''
    									}
    									sh '''docker push yuriyeom/dev-admin-service '''
    								}
    						}
    						stage('Run Container on SSH Dev Server'){
    								steps{
    									sshagent (credentials: ['ssh-agent']) {
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker rm -f dev-admin-service'"
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker rmi -f yuriyeom/dev-admin-service'" 
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker pull yuriyeom/dev-admin-service:latest'"
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker run -d --name dev-admin-service -p 8001:8001 --network nnz-network --add-host=host.docker.internal:host-gateway -e SPRING_PROFILES_ACTIVE=dev -e JAVA_OPTS=-Djasypt.encryptor.password={암호화 키} yuriyeom/dev-admin-service'"
    									}
    								}
    						}
    
    					}
    				}
    				stage('crawling') {
    					when {branch 'dev_crawling_service'}
    
    					stages{ 
    						stage('Docker build image'){
    								steps{
    									dir("./be/nnz-crawling") {
    										sh '''docker build . -t yuriyeom/dev-crawling-service:latest'''
    									} 
    								}
    							}		
    						
    						stage('Docker push image'){
    								steps {
    									withCredentials([string(credentialsId: 'dockerHubPwd', variable: 'dockerHubPwd')]) {
    										sh '''docker login -u yuriyeom -p ${dockerHubPwd}'''
    									}
    									sh '''docker push yuriyeom/dev-crawling-service '''
    								}
    						}
    						stage('Run Container on SSH Dev Server'){
    								steps{
    									sshagent (credentials: ['ssh-agent']) {
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker rm -f dev-crawling-service'"
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker rmi -f yuriyeom/dev-crawling-service'" 
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker pull yuriyeom/dev-crawling-service:latest'"
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker run -d --name dev-crawling-service -p 8002:8002 --network nnz-network --add-host=host.docker.internal:host-gateway -e SPRING_PROFILES_ACTIVE=dev -e JAVA_OPTS=-Djasypt.encryptor.password={암호화 키} yuriyeom/dev-crawling-service'"
    									}
    								}
    						}
    
    					}
    				}
    				
    				/*
    				stage('crawling') {
    					when {branch 'dev_crawling_service'} // 브랜치 이름 바꾸기
    
    					stages{ 
    						stage('Docker build image'){
    								steps{
    									dir("./be/JenkinsTest") { // 폴더 이름 바꾸기
    										sh '''docker build . -t yuriyeom/dev_jenkins_test:latest''' // 이미지 이름 바꾸기
    									} 
    								}
    							}		
    						
    						stage('Docker push image'){
    								steps {
    									withCredentials([string(credentialsId: 'dockerHubPwd', variable: 'dockerHubPwd')]) {
    										sh '''docker login -u yuriyeom -p ${dockerHubPwd}'''
    									}
    									sh '''docker push yuriyeom/dev_jenkins_test ''' // 이미지 이름 바꾸기
    								}
    						}
    						stage('Run Container on SSH Dev Server'){
    								steps{
    									sshagent (credentials: ['ssh-agent']) {
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker rm -f dev_jenkins_test'" // 컨테이너 이름 바꾸기
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker rmi -f yuriyeom/dev_jenkins_test'" // 이미지 이름 바꾸기
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker pull yuriyeom/dev_jenkins_test:latest'" // 이미지 이름 바꾸기
    										sh "ssh -o StrictHostKeyChecking=no ubuntu@k8b207.p.ssafy.io 'sudo docker run -d --name dev_jenkins_test -p 8080:8080 --add-host=host.docker.internal:host-gateway -e SPRING_PROFILES_ACTIVE=dev -e JAVA_OPTS=-Djasypt.encryptor.password={암호화 키} yuriyeom/dev_jenkins_test'" // 컨테이너 이름, 포트 번호, 이미지 이름 바꾸기
    									}
    								}
    						}
    
    					}
    				}
    				*/
    			}
    		}
    		
        }
    }
    ```
    

### FrontEnd - React

1. 젠킨스에 nodejs 플러그인 설치
2. 젠킨스 설정 - ****Global Tool Configuration에서 NodeJS 버전 등록****
    
    ![image](https://github.com/yuriyeom/cicd-study/assets/43941336/43ce4800-da20-4c9d-b8ab-eb66d551a3fe)
    
3. 젠킨스에서 New Pipeline
    
    `Build when a change is pushed to GitLab. GitLab webhook URL: http://k8b207.p.ssafy.io:9090/project/nnz-react-admin`
    
    체크해준다.
    
    고급 - Secret token Generate해서 토큰만들고 웹훅 만들러 깃랩으로 간다.
    
4. 깃랩에서 설정 - 웹훅
    
    ![image](https://github.com/yuriyeom/cicd-study/assets/43941336/7a36e3ab-5d78-454a-aa6d-f0e1dc7c5514)
    
    URL에 3번에서 체크한 곳에 있는 URL을 넣어준다.
    
    Secret token은 3번에서 만들었던 토큰을 넣어준다.
    
    체크된 Push events에는 어떤 브랜치에 웹훅을 걸건지 써준다.
    
    admin에 걸어놨다.
    
    add webhook 한 후 Test 해본다.
    
5. 젠킨스로 돌아와서 스크립트 작성
    
    ```bash
    pipeline {
       agent any
       stages {
           stage('Git Clone') {
               steps {
                   git branch: 'admin',credentialsId: 'gitlab-username', url: 'https://lab.ssafy.com/s08-final/S08P31B207.git'
               }
           }
           
            stage('Build') {
               steps {
                   dir('fe') {
                       nodejs(nodeJSInstallationName: 'NodeJS 18.12.1') {
                           sh 'rm -rf node_modules package-lock.json'
                           sh 'npm install -g npm@9.6.1'
                           sh 'npm install && CI=false npm run build'
                        }
                   }
               }
           }
           
           stage('Deploy'){
               steps{
                    dir('fe/build') {
                       sshagent (credentials: ['ssh-agent']) {
                            sh 'ls'
                            sh 'pwd'
                            sh 'scp -r /var/jenkins_home/workspace/nnz-react-admin/fe/build ubuntu@k8b207.p.ssafy.io:/home/ubuntu/'
                       }            
                    }
               }
           }
        }
    }
    ```
    

6. NGINX 설정 변경

```bash
location / {
        #autoindex on;
        root /home/ubuntu/build;
        index index.html index.htm;

        try_files $uri /index.html;
}
```

# 로컬에서 BackEnd 서비스 실행 방법

### 모든 프로젝트에 적용

1. 인텔리제이에서 Edit Configurations → Add VM options에 Djasypt.encryptor.password={암호화 키} 설정
2. 인텔리제이에서 Edit Configurations → active profiles : dev

discovery-service와 gateway-service를 실행시킨 후 user-service, nanum-service, show-service, crawling-service, tag-service, admin-service를 실행시킨다.

# 설정 파일

- BackEnd
    - gateway-service
        
        ```yaml
        server:
          port: 8000
        eureka:
          client:
            register-with-eureka: true
            fetch-registry: true
            service-url:
              defaultZone: ENC(+7HkpgsS1BJwy0smEij0gewhZS/W2kqqtZqpMk64g7ujNZJ1IlD6RrcdUH0mCEns1xRiZd8cCko=)
        
        spring:
          application:
            name: DEV-GATEWAY-SERVICE
          redis:
            host: ENC({암호화한 host})
            port: 6379
            password: ENC({암호화한 password})
        
          cloud:
            gateway:
              default-filters:
                - DedupeResponseHeader=Access-Control-Allow-Credentials Access-Control-Allow-Origin
                - AddResponseHeader=Access-Control-Allow-Headers, *
                - AddResponseHeader=Access-Control-Allow-Methods, *
                - name: JwtFilter
                  args:
                    baseMessage: Jwt Filter
                    preLogger: false
                    postLogger: false
              globalcors:
                corsConfigurations:
                  '[/**]':
                    allowedOrigins: 'https://k8b207.p.ssafy.io'
                    allow-credentials: true
                    allowedHeaders: '*'
                    allowedMethods: 
                      - GET
                      - POST
                      - DELETE
                      - PATCH
                      - OPTIONS
                add-to-simple-url-handler-mapping: true
              routes:
                - id: DEV-USER-SERVICE
                  uri: lb://DEV-USER-SERVICE
                  predicates:
                    - Path=/user-service/**
                - id: DEV-SHOW-SERVICE
                  uri: lb://DEV-SHOW-SERVICE
                  predicates:
                    - Path=/show-service/**
                - id: DEV-ADMIN-SERVICE
                  uri: lb://DEV-ADMIN-SERVICE
                  predicates:
                    - Path=/admin-service/**
                - id: DEV-TAG-SERVICE
                  uri: lb://DEV-TAG-SERVICE
                  predicates:
                    - Path=/tag-service/**
                - id: DEV-NANUM-SERVICE
                  uri: lb://DEV-NANUM-SERVICE
                  predicates:
                    - Path=/nanum-service/**
                - id: DEV-TAG-SERVICE
                  uri: lb://DEV-TAG-SERVICE
                  predicates:
                    - Path=/tag-service/**
        
        jwt:
          secret-key: ENC({암호화한 secret-key})
        
        #yml 암호화 yml 설정
        jasypt:
          encryptor:
            bean: jasyptStringEncryptor
            algorithm: PBEWithMD5AndDES
            iv-generator-classname: org.jasypt.iv.NoIvGenerator
        ```
        
    - discovery-service
        
        ```yaml
        server:
          port: 8761
        
        spring:
          application:
            name: discovery-service
        
        eureka:
          client:
            fetch-registry: false
            register-with-eureka: false
        ```
        
    - nanum-service, show-service, crawling-service, tag-service, admin-service, user-service
        
        ```yaml
        server:
          port: {서비스별 포트 번호}
        spring:
          application:
            name: {서비스별 애플리케이션 이름}
          datasource:
            url: ENC({암호화한 url})
            username: ENC({암호화한 username})
            password: ENC({암호화한 password})
            driver-class-name: com.mysql.cj.jdbc.Driver
          servlet:
            multipart:
              enabled: true
              max-file-size: 50MB
              max-request-size: 50MB
          transaction:
            default-timeout: 10
        
          jpa:
            open-in-view: false
            show-sql: true
            hibernate:
              #      ddl-auto: none
              ddl-auto: update
            properties:
              hibernate:
                globally_quoted_identifiers: true
                format_sql: true
        
          kafka:
            prefix: pd-
            bootstrap-servers: ENC({암호화한 kafka 서버})
            consumer:
        #      group-id: show-service-1 # ex) user-service-1
              auto-offset-reset: earliest
              key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
              value-deserializer: org.apache.kafka.common.serialization.StringDeserializer
            producer:
        #      topic: test-show # 데이터를 퍼블리싱할 곳의 토픽 ex) dev-user
              key-serializer: org.apache.kafka.common.serialization.StringSerializer
              value-serializer: org.apache.kafka.common.serialization.StringSerializer
          redis:
            host: ENC({암호화한 host})
            port: 6379
            password: ENC({암호화한 password})
        
        eureka:
          client:
            register-with-eureka: true
            fetch-registry: true
            service-url:
              defaultZone: ENC({암호화한 eureka 서버})
        
        logging:
          level:
            com:
              amazonaws:
                util:
                  EC2MetadataUtils: ERROR
        #    org:
        #      hibernate:
        #        SQL: DEBUG
        #        type: TRACE
        
        jasypt:
          encryptor:
            bean: jasyptStringEncryptor
            algorithm: PBEWithMD5AndDES
            iv-generator-classname: org.jasypt.iv.NoIvGenerator
        
        notification:
          mattermost:
            enabled: true
            webhook-url: ENC({암호화한 mattermost webhook url})
            channel: # ?? ??? ??? ?? ?? ??? ??? ?? ? ????
            pretext: Dev NanumService Error # attachments? ??? ??? ?? ?? ??? ??
            #    color: # attachment? ?? ??? ??. default=red
            author-name: mmSender # attachment? ??? ??? ??
            author-icon: https://mattermost.com/wp-content/uploads/2022/02/icon.png # author-icon ??? ?? ???? url??
        #    footer: # attachment? ??? ?? ??. default=?? ??
        
        cloud:
          aws:
            s3:
              bucket: nnz-bucket
            credentials:
              access-key: ENC({암호화한 access-key})
              secret-key: ENC({암호화한 secret-key})
            region:
              static: ap-southeast-2
              auto: false
            stack:
              auto: false
        
        fcm:
          json:
            path: /home/home/fcm/nnz-firebase.json
        
        ncp-sms:
          access-key: ENC({암호화한 access-key})
          secret-key: ENC({암호화한 secret-key})
          service-id: ENC({암호화한 service-id})
          from: ENC({암호화한 발신자})
        
        jwt:
          secret-key: ENC({암호화한 secret-key})
          expiration-period:
            access-token: 25200000 # 7day
            refresh-token: 1296000000 # 15day
        
        web-driver:
          chrome:
            driver-path: /usr/bin/chromedriver
        ```
        

# 설정 파일 암호화

1. 의존성 추가

```java
implementation 'com.github.ulisesbocchio:jasypt-spring-boot-starter:3.0.3'
```

1. 설정 파일에 추가

```yaml
jasypt:
  encryptor:
    bean: jasyptStringEncryptor
    algorithm: PBEWithMD5AndDES
    iv-generator-classname: org.jasypt.iv.NoIvGenerator
```

1. 암호화 Config 파일 추가

```java
@Configuration
public class JasyptConfig {
    @Value("${jasypt.encryptor.password}")
    private String PASSWORD;

    @Bean("jasyptStringEncryptor")
    public StringEncryptor stringEncryptor(){
        PooledPBEStringEncryptor encryptor = new PooledPBEStringEncryptor();
        SimpleStringPBEConfig config = new SimpleStringPBEConfig();
        config.setPassword(PASSWORD);
        config.setPoolSize("1");
        config.setAlgorithm("PBEWithMD5AndDES");
        config.setStringOutputType("base64");
        config.setKeyObtentionIterations("1000");
        config.setSaltGeneratorClassName("org.jasypt.salt.RandomSaltGenerator");
        encryptor.setConfig(config);
        return encryptor;
    }
}
```

1. docker run할 때 암호화 키를 환경변수 옵션으로 준다.

```java
-e JAVA_OPTS=-Djasypt.encryptor.password={암호화 키}
```

1. 옵션으로 준 jasypt 암호화 키 제공하려면 프로젝트 Dockerfile에서도 jar 파일을 아래와 같이 실행시킨다.

```java
ENTRYPOINT ["sh", "-c", "java ${JAVA_OPTS} -jar /app.jar"]
```

# 기타 서비스 설정

### RDS 연결

- AWS RDS 인스턴스(프리티어) 생성
    - DB 엔진: `MySql 8.0.31`
    - DB 인스턴스 식별자 입력: dodo-db
    - 마스터 사용자 이름, 패스워드 입력
    - 인스턴스 구성: `db.t3.micro`
    - 스토리지
        - 범용 SSD(gp2)
        - 할당된 스토리지 20
    - 연결 추가 구성에서 퍼블릭 액세스 가능 선택
    - 데이터베이스 인증: 암호 인증 선택
    - 생성
- DB 인스턴스 VPC에 인바운드 규칙 설정
    - IP 버전: `IPv4`
    - 유형: `MYSQL/Aurora`
    - 프로토콜: `TCP`
    - 포트 범위: `3306`
- 데이터베이스 파라미터 그룹 설정
    - RDS >  파라미터 그룹에서 파라미터 그룹 생성
        - time_zone 변경 → `Asia/Seoul`
        - 아래 Character Set 변경 → `utf8mb4`
            - character_set_client
            - character_set_connection
            - character_set_database
            - character_set_filesystem
            - character_set_results
            - charcater_set_server
            - collation_connection
            - collation_server
    - RDS > 데이터베이스 > dodo-db > 수정
        - 추가 구성 > 데이터베이스 옵션 > DB 파라미터 그룹을 새로 생성한 파라미터 그룹으로 변경
    - 계속 > 수정 예약: 즉시 적용 선택 후 DB 인스턴스 수정

### FCM PUSH 알림

1. Firebase 프로젝트 생성
2. 프로젝트 Firebase 추가준비

![image](https://github.com/yuriyeom/cicd-study/assets/43941336/bbe04c8d-2e1e-4621-aa25-d5788ef0f61b)

3. Firebase CLI - firebase 로그인

```bash
firebase login
```

4.  FlutterFire CLI 설치 및 실행 

```bash
// FlutterFire 설치
dart pub global activate flutterfire_cli

//FlutterFire 실행 
flutterfire configure --project=naneozoo
```

5. Firebase 초기화 및 플러그인 추가 

```bash
import 'package:firebase_core/firebase_core.dart';
import 'firebase_options.dart';

// ...

await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
);
```
